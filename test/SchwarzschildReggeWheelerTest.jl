#--------------------------------------------------------------------
# Spacetime Discretization methods in Julia
# Soham 04-2018
# Wave equation on Schwarzschild; compare with Regge-Wheeler
#--------------------------------------------------------------------

using Einsum

#--------------------------------------------------------------------
# Set grid size and initial data 
#--------------------------------------------------------------------
M          = 1.0
ğ’          = 0
Ï‰          = 0.1
P1, P2     = 20, 20
Umin, Umax = -3M, -7M
Vmin, Vmax =  3M,  7M

SUV = ProductSpace{GaussLobatto{U,P1}, GaussLobatto{V,P2}}

#--------------------------------------------------------------------
# Define derivative and boundary operators
#--------------------------------------------------------------------
ğ”¹ = boundary(Null, SUV)

#--------------------------------------------------------------------
# Define coordinates and their associated derivatives
#--------------------------------------------------------------------
ğ•Œ = Field(SUV, (U,V)->U)
ğ• = Field(SUV, (U,V)->V)
Î¸ = Field(SUV, (ğ‘¼,ğ‘½)->pi/2)
Ï• = Field(SUV, (ğ‘¼,ğ‘½)->0)
Ã¸ = zero(SUV) 
Ã˜ = zero(Null, SUV) 

ğ‘¼ = (Umax + Umin)/2 + (Umax - Umin)/2*ğ•Œ  
ğ‘½ = (Vmax + Vmin)/2 - (Vmax - Vmin)/2*ğ•  

t = Field(SUV, (ğ‘¼,ğ‘½)->find_t_of_UV(ğ‘¼, ğ‘½, M), ğ‘¼, ğ‘½)
r = Field(SUV, (ğ‘¼,ğ‘½)->find_r_of_UV(ğ‘¼, ğ‘½, M), ğ‘¼, ğ‘½)

drawpatch(ğ‘¼, "../output/U")
drawpatch(ğ‘½, "../output/V")
drawpatch(t, "../output/t_of_UV")
drawpatch(r, "../output/r_of_UV")

ğ”»ğ‘¼, ğ”»ğ‘½ = derivativetransform(SUV, ğ‘¼, ğ‘½) 
ğ”»Î¸, ğ”»Ï• = Ã˜, Ã˜

#--------------------------------------------------------------------
# Set boundary conditions [Use Regge Wheeler Initial Data]
#--------------------------------------------------------------------

# [1] Computing initial data with ApproxFun code
import Scattering.radialsolve
import ApproxFun.evaluate

rmin, rmax = minimum(r), maximum(r) 
@show rmin
@show rmax

# Boundary conditions for radial solver from Mathematica notebook
Ï•_at_rmin = 1.7907673567951274
Ï•_at_rmax = 2.3370573622442246

function phi_in_UV(t, r, Ï•, Ï‰)
    @assert r >= Ï•.space.domain.a && r <= Ï•.space.domain.b
    return evaluate(Ï•, r)*cos(-Ï‰*t)
end

Ï• = radialsolve(M, Ï‰, ğ’, rmin, rmax, Ï•_at_rmin, Ï•_at_rmax).u
ğ•¤ = Field(SUV, (t,r)->phi_in_UV(t, r, Ï•, Ï‰), t, r) 
ğ•“ = ğ”¹*ğ•¤

#----------------------------------------------------------------------
# Compute the boundary conditions directly from the Mathematica notebook
# A hack, but the only option left.
#----------------------------------------------------------------------

r_l = r.value[:, 1]
t_l = t.value[:, 1]

r_r = r.value[1, :]
t_r = t.value[1, :]

#@show r_l
#@show r_r

# Output copied from Mathematica
Ï•rl = [2.06704, 2.06589, 2.06243, 2.05668, 2.04865, 2.03839, 2.02595,
      2.0114, 1.99487, 1.97653, 1.95661, 1.93542, 1.91339, 1.89103, 
      1.86902, 1.84812, 1.82922, 1.81322, 1.80103, 1.79338, 1.79077]
Ï•rr = [2.06704, 2.06972, 2.07755, 2.08998, 2.10621, 2.12526, 2.14617, 
      2.16804, 2.19007, 2.21162, 2.23219, 2.25139, 2.26896, 2.2847, 
      2.29848, 2.31022, 2.31986, 2.32738, 2.33275, 2.33598, 2.33706]

Ï•l = Ï•rl.*cos.(Ï‰.*t_l)
Ï•r = Ï•rr.*cos.(Ï‰.*t_r)

b = zeros(21, 21)
b[:, 1] = Ï•l
b[1, :] = Ï•r

ğ•“ = Boundary(SUV, b)
Ï = 0 

#--------------------------------------------------------------------
# Define metric functions 
# Tests ----------------
#       [1] Christoffel Symbols / Mathematica [done]
#       [2] Ricci Tensor upto a constant / Mathematica [done]
#       [3] Eigen value plots -> not so useful for our case [done]
#--------------------------------------------------------------------

ğ’ˆğ‘¼ğ‘½ = -32*(M^3/r)*(exp(-r/2M))
ğ’ˆÎ¸Î¸ = r^2
ğ’ˆÏ•Ï• = (r*sin(Î¸))^2

ğ’ˆğ‘¼ğ‘¼ = ğ’ˆğ‘½ğ‘½ = Ã¸
ğ’ˆğ‘¼Î¸ = ğ’ˆğ‘¼Ï• = Ã¸
ğ’ˆğ‘½Î¸ = ğ’ˆğ‘½Ï• = Ã¸
ğ’ˆÎ¸Ï• = Ã¸

ğ•˜    = Metric{dd, 4}([ğ’ˆğ‘¼ğ‘¼, ğ’ˆğ‘¼ğ‘½, ğ’ˆğ‘¼Î¸, ğ’ˆğ‘¼Ï•, 
                           ğ’ˆğ‘½ğ‘½, ğ’ˆğ‘½Î¸, ğ’ˆğ‘½Ï•,
                                ğ’ˆÎ¸Î¸, ğ’ˆÎ¸Ï•,
                                     ğ’ˆÏ•Ï•])

ğ•˜inv = inv(ğ•˜) 
ğ”»    = Derivative{u, 4}([ğ”»ğ‘¼, ğ”»ğ‘½, ğ”»Î¸, ğ”»Ï•])
Î“    = Christoffel(ğ•˜)
@einsum Î“[m, i, j] = (1/2)*ğ•˜inv[m,k]*(ğ”»[j]*ğ•˜[k,i]+  ğ”»[i]*ğ•˜[k,j] - ğ”»[k]*ğ•˜[i,j])
println("Finished computing auxilliary quantities. Computing the operator")

#--------------------------------------------------------------------
# Now construct the operator [Testing in Progress] 
# Tests ------------------------------------------
#       [1] Compute the residual with the solution generated by ApproxFun [done]
#       [2] Compare ApproxFun solution with Cardoso et al. solution [done; doesn't agree]
#       [3] Compare two different definitions of operators
#       [4] Compare solution with Cardoso et. al. [done, in part] 

#--------------------------------------------------------------------
ğ•ƒ1 = ( sum(ğ•˜inv[j,k]*ğ”»[j]*ğ”»[k] for j in 1:dim(ğ•˜), k in 1:dim(ğ•˜))  
     - sum(ğ•˜inv[j,k]*Î“[l,j,k]*ğ”»[l] for j in 1:dim(ğ•˜), k in 1:dim(ğ•˜), l in 1:dim(ğ•˜)) ) 

#--------------------------------------------------------------------
# Solve the system [also check the condition number and eigen values]
#--------------------------------------------------------------------
ğ•¨ = solve(ğ•ƒ1 + ğ”¹, Ï + ğ•“) 
println("Finished solve. Generating plots.")

# Check if the solution matches the Mathematica code with initial 
# conditions from ApproxFun
@show r.value[10, 10]
@show ğ•¨.value[10, 10]

# Compute the operator on the solution from ApproxFun
ğ•¤res = ğ•ƒ1*ğ•¤

drawpatch(ğ•¨,    "../output/schwarzschild-field")
drawpatch(ğ•¤,    "../output/solution-field")
drawpatch(ğ•¤res, "../output/solution-res-field")
drawpatch(ğ•¨-ğ•¤,  "../output/error-schwarzschild")

@show maximum(abs(ğ•¨-ğ•¤))
@show maximum(abs(ğ•¤res))

